/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2023 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * Non-trig mandelbulber pow2 version based on pow2 code from Davis Makin
 * ref: https://www.facebook.com/david.makin.7

 * This file has been autogenerated by tools/populateUiInformation.php
 * from the file "fractal_mandelbulb_pow2_v1.cpp" in the folder formula/definition
 * D O    N O T    E D I T    T H I S    F I L E !
 */

REAL4 MandelbulbPow2V4Iteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	REAL t = 0.0; // temp
	REAL r = aux->r;
	REAL cosPhi;
	REAL sinPhi;
	REAL cosTheta1;
	REAL cosTheta2;
	REAL cosTheta;
	REAL sinTheta;


	if (z.x * z.x + z.y * z.y == 0.0f)
	{
		z.y = -z.z * z.z;
		z.z = 0.0f;
	}

/*	// Undefined case in which x=y=0 (or x=y=z=0)
	if (z.x == 0.0f && z.y == 0.0f)
	{
		// Assign evaluated phi values
		cosPhi = 1.0f;
		sinPhi = 0.0f;

		// Assign evaluated theta values if z=0
		if (z.z == 0.0f)
		{
			cosTheta = 1.0f;
			sinTheta = 0.0f;
		}
		// Assign evaluated theta values if z!=0
		else
		{
			cosTheta = -1.0f;
			sinTheta = 0.0f;
		}
	}

	// Remaining defined cases
	else*/
	{
		REAL4 v = z / r;
		REAL4 w = (REAL4){z.x, z.y, 0.0f, 0.0f};
		w = normalize(w);
		cosPhi = w.x * w.x - w.y * w.y;

		if (fractal->transformCommon.functionEnabledTFalse
			&& aux->i >= fractal->transformCommon.startIterationsT
			&& aux->i < fractal->transformCommon.stopIterationsT)
				 cosPhi = -cosPhi;


		t = w.y * w.x;
		sinPhi = t + t;
		//sinPhi = w.y * w.x + w.y * w.x;

		cosTheta1 = v.x * w.x + v.y * w.y;
		cosTheta2 = cosTheta1;

		if (fractal->transformCommon.functionEnabledNFalse
				&& aux->i >= fractal->transformCommon.startIterationsN
				&& aux->i < fractal->transformCommon.stopIterationsN)
			cosTheta1 = -cosTheta1;


		cosTheta = cosTheta1 * cosTheta2 - v.z * v.z;
		//t =v.z * cosTheta1;
		//sinTheta = t + t;
		sinTheta = v.z * cosTheta1 + v.z * cosTheta2;
	}

	REAL4 f = z;
	REAL4 g = z;

	aux->DE = aux->DE * fractal->transformCommon.scale2 * aux->r + fractal->analyticDE.offset1;
	// function pairs
	//  1. f_A, g_A - aka spherical representation 3D
	if (fractal->transformCommon.functionEnabledM
			&& aux->i >= fractal->transformCommon.startIterationsA
			&& aux->i < fractal->transformCommon.stopIterationsA)
	{
		//f = r * r * (REAL4){-sinPhi * cosTheta, cosPhi * cosTheta, 0, 0.0};
		//g = (REAL4){-sinTheta / (cosPhi * cosTheta), 0, 1, 0.0};
		z = r * r * (REAL4){cosPhi * cosTheta, sinPhi * cosTheta, sinTheta, 0.0f};
	}

	// 2. f_A, g_A - aka sphercical representation 3D (inverted 3rd coordinate in g_A)
	if (fractal->transformCommon.functionEnabledBFalse
			&& aux->i >= fractal->transformCommon.startIterationsB
			&& aux->i < fractal->transformCommon.stopIterationsB)
	{
	//	f = r * r * (REAL4){-sinPhi * cosTheta, cosPhi * cosTheta, 0, 0.0};
	//	g = (REAL4){sinTheta / (cosPhi * cosTheta), 0, 1, 0.0};
		z = r * r * (REAL4){cosPhi * cosTheta, sinPhi * cosTheta, -sinTheta, 0.0f};
	}

	// 3. f_B, g_B - aka space filling tunnels
	if (fractal->transformCommon.functionEnabledCFalse
			&& aux->i >= fractal->transformCommon.startIterationsC
			&& aux->i < fractal->transformCommon.stopIterationsC)
	{
		g = (REAL4){cos(z.x), cos(z.y), cos(z.z), 0.0f};
		z.x = g.z - g.y;
		z.y = g.x - g.z;
		z.z = g.y - g.x ;
	}

	// 4. f_C, g_C - aka swirl
	if (fractal->transformCommon.functionEnabledDFalse
			&& aux->i >= fractal->transformCommon.startIterationsD
			&& aux->i < fractal->transformCommon.stopIterationsD)
	{
		f = (REAL4){z.x * z.x, z.y * z.y, z.z * z.z, 0.0f};
		g = (REAL4){cos(z.x), cos(z.y), cos(z.z), 0.0f};
		z.x = f.y * g.z - f.z * g.y;
		z.y = f.z * g.x - f.x * g.z;
		z.z = f.x * g.y - f.y * g.x;
	}

	// 5. f_D, g_D - aka force? deformed pwr2, NO Z
	if (fractal->transformCommon.functionEnabledEFalse
			&& aux->i >= fractal->transformCommon.startIterationsE
			&& aux->i < fractal->transformCommon.stopIterationsE)
	{
	//	f = r * r * (REAL4){-sinPhi, cosPhi, 0.0f, 0.0f};
	//	g = (REAL4){0.0f, 0.0f, 1.0f, 0.0f};
		z = r * r * (REAL4){cosPhi, sinPhi, 0.0f, 0.0f};
	}

	// 6. f_E, g_E - aka other forms
	if (fractal->transformCommon.functionEnabledFFalse
			&& aux->i >= fractal->transformCommon.startIterationsF
			&& aux->i < fractal->transformCommon.stopIterationsF)
	{
		f = (REAL4){z.x * z.x * z.y, z.y * z.y, z.z * z.z, 0.0f};
		g = (REAL4){1.0f, cos(z.z), 1.0f, 0.0f};

		//z = cross(f, g);
		//z.x = f.y * g.z - f.z * g.y;
	//	z.y = f.z * g.x - f.x * g.z;
		//z.z = f.x * g.y - f.y * g.x;
		//z = cross(f, g);
		z.x = f.y - f.z * g.y;
		z.y = f.z - f.x;
		z.z = f.x * g.y - f.y;
	}

	// 7. User defined (here without exception handling as this becomes changed by the user)
	//
	// Does not include exception handling as this is starting point for user input and
	// we do not incorporate exception handling for user input yet.
	if (fractal->transformCommon.functionEnabledGFalse
			&& aux->i >= fractal->transformCommon.startIterationsG
			&& aux->i < fractal->transformCommon.stopIterationsG)
	{
	//	f = r * r * (REAL4){-sinPhi, cosPhi, 0.0f, 0.0f};
	//	g = (REAL4){-sinTheta / cosPhi, 0.0f, cosTheta, 0.0f};

	//	z = cross(f, g);

		//z.x = f.y * g.z - f.z * g.y;
	//	z.y = f.z * g.x - f.x * g.z;
		//z.z = f.x * g.y - f.y * g.x;
	//	z.x = f.y * g.z - 0.0f;
	//	z.y = 0.0f - f.x * g.z;
	//	z.z = 0.0f - f.y * g.x;


		z = r * r * (REAL4){-cosPhi * cosTheta, sinPhi * cosTheta, sinTheta, 0.0f};

	}


	if (fractal->transformCommon.functionEnabledHFalse
			&& aux->i >=fractal->transformCommon.startIterationsH
			&& aux->i < fractal->transformCommon.stopIterationsH)
	{
		z = r * r * (REAL4){sinPhi * cosTheta, cosPhi * cosTheta, sinTheta, 0.0f};
	}
	// Apply scheme

	// scheme 0 = no const, scheme 1 = +origPt, scheme 3 = + juliaC
	//	z = cross(f, g);
	//	z = r * r *(REAL4){sinPhi*cosTheta, cosPhi*cosTheta, sinTheta, 0.0f};



	// z.z scale
	if (fractal->transformCommon.functionEnabledPFalse
			&& aux->i >= fractal->transformCommon.startIterationsP
			&& aux->i < fractal->transformCommon.stopIterationsP)
	{
		z.z *= fractal->transformCommon.scale1;
	}

	if (fractal->transformCommon.functionEnabledSFalse
			&& aux->i >= fractal->transformCommon.startIterationsS
			&& aux->i < fractal->transformCommon.stopIterationsS)
	{
		z *= fractal->transformCommon.scaleA1;
		aux->DE *= fabs(fractal->transformCommon.scaleA1);
	}

	if (fractal->transformCommon.functionEnabledJFalse
			&& aux->i >=fractal->transformCommon.startIterationsJ
			&& aux->i < fractal->transformCommon.stopIterationsJ)
		z += fractal->transformCommon.offset000; // plus  julia

	if (fractal->transformCommon.functionEnabledRFalse
			&& aux->i >= fractal->transformCommon.startIterationsR
			&& aux->i < fractal->transformCommon.stopIterationsR)
		z = Matrix33MulFloat4(fractal->transformCommon.rotationMatrix, z);

	if (fractal->transformCommon.functionEnabledXFalse
			&& aux->i >=fractal->transformCommon.startIterationsX
			&& aux->i < fractal->transformCommon.stopIterationsX)
		z += aux->const_c * fractal->transformCommon.constantMultiplier111;

	// aux->color
	if (fractal->foldColor.auxColorEnabledFalse && aux->i >= fractal->foldColor.startIterationsA
			&& aux->i < fractal->foldColor.stopIterationsA)
	{
		REAL colAdd = fractal->foldColor.difs0000.w + aux->i * fractal->foldColor.difs0;

		// last two z lengths
		if (fractal->foldColor.auxColorEnabledAFalse)
		{
			REAL lastVec = 0.0f;
			REAL4 oldPt = aux->old_z;
			REAL lastZ = length(oldPt); // aux->old_r;
			REAL newZ = length(z);
			if (fractal->transformCommon.functionEnabledBwFalse) lastVec = newZ / lastZ;
			if (fractal->transformCommon.functionEnabledByFalse) lastVec = lastZ / newZ;
			if (fractal->transformCommon.functionEnabledBzFalse) lastVec = fabs(lastZ - newZ);
			lastVec *= fractal->foldColor.difs1;
			colAdd += lastVec;

			aux->old_z = z; // update for next iter
		}

	//	colAdd += fractal->foldColor.difs0000.x * temp;
		colAdd += fractal->foldColor.difs0000.y * sinPhi;
		colAdd += fractal->foldColor.difs0000.z * fabs(z.x * z.y);

		if (!fractal->foldColor.auxColorEnabledBFalse)
			aux->color = colAdd;
		else
			aux->color += colAdd;
	}

	return z;
}
