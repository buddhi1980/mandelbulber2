/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2024 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * KochV2Iteration
 * Based on Knighty's Kaleidoscopic IFS 3D Fractals, described here:
 * http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/

 * This file has been autogenerated by tools/populateUiInformation.php
 * from the file "fractal_koch_v4.cpp" in the folder formula/definition
 * D O    N O T    E D I T    T H I S    F I L E !
 */

REAL4 EiffieCarIteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	Q_UNUSED(z);

	REAL4 p0 = aux->const_c;
	REAL4 p = p0;

	p.z = p0.z + fractal->transformCommon.scale015;

	REAL r = sqrt(p.z * p.z + p.x * p.x);

	REAL4 tp = p0;
	tp.y = max(fabs(p.y) - fractal->transformCommon.scale05, 0.0f);
	tp.z = max(r - fractal->transformCommon.offset2, 0.0f);
	tp.x = max(-p.z + fractal->transformCommon.offset105, 0.0f);
	REAL d = length(tp) - fractal->transformCommon.offset01; // round
	d = max(d, p.x - fractal->transformCommon.scale1p1); // boot
	if (fractal->transformCommon.functionEnabledDFalse) d = 100.0f;


	p.z = p0.z - fractal->transformCommon.offsetD0; // locate z
	p.x = p0.x + fractal->transformCommon.minR2p25; //wheels and gurads locate x
	p.y = fabs(fabs(p.y) - fractal->transformCommon.minR06); // locate y
	p.x = fabs(p.x) - fractal->transformCommon.offsetR1; //wheels and gurads dist apart
	r = sqrt(p.z * p.z + p.x * p.x);
	tp.x = max(r - fractal->transformCommon.scale025, 0.0f); // guard rad
	tp.y = max(p.y - fractal->transformCommon.offsetBp01 - 0.05f, 0.0f);
	tp.z = max(-p.z - 0.08f, 0.0f); // mmmmmmmmmmmmmmmmmmmmm

	// IQ's smooth minium function.
	if (!fractal->transformCommon.functionEnabledEFalse)
	{
		d = -log(exp(-fractal->transformCommon.scale8 * d)
				 + exp(-fractal->transformCommon.scale8 * (length(tp) - 0.04f)))
				/ fractal->transformCommon.scale8;
	}
	else
	{

		REAL b = length(tp) - 0.04f;
		REAL h = clamp( 0.5f + 0.5f * (b - d) / 0.2f, 0.0f, 1.0f);
		d = mix(b, d, h) - h * (1.0f - h) * 0.2f;
	}

	d = max(d, -max(p.y - 0.165f, r - 0.24f)); // guard and car

//	if (fractal->transformCommon.functionEnabledEFalse)  d = 100.0;

	//wheels
	REAL4 zc = p;
	REAL cylR = native_sqrt(zc.x * zc.x + zc.z * zc.z) - fractal->transformCommon.offset02; // tyre OD is offseto2
	cylR = max(fabs(cylR) - fractal->transformCommon.offsetp05, cylR); // tyre
	REAL cylH = fabs(zc.y) - fractal->transformCommon.offsetp1; //tyre width

	cylR = max(cylR, 0.0f);
	cylH = max(cylH, 0.0f);
	REAL cylD = native_sqrt(cylR * cylR + cylH * cylH);
	cylD = min(max(cylR, cylH), 0.0f) + cylD;

	REAL d2 = cylD - 0.02f; // round tyre
	if (fractal->transformCommon.functionEnabledCFalse)  d2 = 100.0f;
//	REAL d2 = sqrt(tp.y * tp.y + tp.z * tp.z) - .02;

	d = min(d, d2);
	aux->dist = d;

	if (aux->dist == d2) aux->color = 3.0f;
	else aux->color = 5.0f;

	return z;
}
